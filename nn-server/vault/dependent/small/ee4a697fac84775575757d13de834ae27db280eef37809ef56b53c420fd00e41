"def write_tmp(content):\n    tmp = tempfile.mkstemp()[1]\n    with open(tmp,\"w\") as f:\n        if content is not None:\n            f.write(content)\n    return tmp\n\ndef merge(upstream, base, modified, labels):\n    #NamedTemporaryFile does NOT work properly with diff3!\n    tmp1 = write_tmp(upstream)\n    tmp2 = write_tmp(base)\n    tmp3 = write_tmp(modified)\n    try:\n        stdout = \"\"\n        cmd = [\"diff3\", tmp1, tmp2, tmp3, \"-m\"]\n        for n in range(3):\n            cmd += [\"-L\", labels[n]]\n\n        cmd = \" \".join(cmd)\n        process = subprocess.run(cmd,shell=True,stdout=PIPE,stderr=PIPE)\n\n        if process.returncode == 2:\n            print(process.stderr.decode())\n            return None, None\n        stdout = process.stdout.decode()\n    finally:\n        os.unlink(tmp1)\n        os.unlink(tmp2)\n        os.unlink(tmp3)\n    return stdout, process.returncode\n\ndef analyze_conflict(conflict, labels):\n    for token in tokens:\n        tokstr = 7 * token + \" \"\n        for label in labels:\n            tokstr2 = tokstr + label\n            if tokstr2 in conflict:\n                return None\n    return conflict\n\n\ndef main():\n    global state, upstream, base, modified, labels\n    violations = []\n    if PINS.upstream_stage.updated:\n        violations.append(\"upstream_stage\")\n    if PINS.base.updated and state != \"passthrough\":\n        violations.append(\"base\")\n\n    zero_modify = (not PINS.modified.defined)\n\n    if PINS.modified.updated:\n        modified = PINS.modified.value\n        if modified.strip() == \"\":\n            zero_modify = True\n        else:\n            if upstream is None:\n                upstream = PINS.upstream.value\n            if modified == upstream:\n                zero_modify = True\n\n        if zero_modify:\n            if state == \"conflict\":\n                PINS.conflict.set(no_conflict)\n            state = \"passthrough\"\n    if state == \"passthrough\":\n        if not zero_modify:\n            print()\n            state = \"modify\"\n\n    if state == \"passthrough\": #no modifications at all\n        if PINS.conflict.updated and PINS.conflict.value.strip(\"\\n \") not in (\"\", no_conflict):\n            print(\"warning: edit pin 'conflict' should not be modified when there is no conflict\")\n        v = PINS.upstream.value\n        PINS.base.set(v)\n        PINS.modified.set(v)\n        PINS.merged.set(v)\n    elif state == \"modify\":\n        if PINS.conflict.updated and PINS.conflict.value.strip(\"\\n \") not in (\"\", no_conflict):\n            print(\"warning: edit pin 'conflict' should not be modified when there is no conflict\")\n        upstream, base, modified = PINS.upstream.value, PINS.base.value, PINS.modified.value\n        if base is None:\n            base = upstream\n        labels = build_labels(upstream, base, modified)\n        merged, has_conflict = merge(upstream, base, modified, labels)\n        if merged is None:\n            return\n        if not has_conflict:\n            PINS.merged.set(merged)\n            PINS.modified.set(merged)\n            PINS.base.set(upstream)\n            state = \"modify\"\n        else:\n            PINS.upstream_stage.set(upstream)\n            PINS.conflict.set(merged)\n            state = \"conflict\"\n    elif state == \"conflict\":\n        if PINS.modified.updated or PINS.base.updated or PINS.upstream_stage.updated:\n            upstream = PINS.upstream_stage.value\n            base = PINS.base.value\n            modified = PINS.modified.value\n            labels = build_labels(upstream, base, modified)\n            merged, has_conflict = merge(upstream, base, modified, labels)\n            if merged is None:\n                return\n            if not has_conflict:\n                PINS.merged.set(merged)\n                PINS.modified.set(merged)\n                PINS.base.set(upstream)\n                PINS.conflict.set(no_conflict)\n                state = \"modify\"\n            else:\n                PINS.conflict.set(merged)\n        elif PINS.conflict.updated:\n            merged = analyze_conflict(PINS.conflict.value, labels)\n            if merged is not None:\n                PINS.merged.set(merged)\n                PINS.modified.set(merged)\n                PINS.base.set(upstream)\n                PINS.conflict.set(no_conflict)\n                state = \"modify\"\n\n    if state == \"conflict\":\n        if fallback_mode == \"no\":\n            m = None\n        elif fallback_mode == \"modified\":\n            m = modified\n        elif fallback_mode == \"upstream\":\n            m = upstream\n        PINS.merged.set(m)\n    for violation in violations:\n        print(\"warning: edit pin '%s' should not be modified\" % violation)\n\nif PINS.fallback_mode.updated:\n    fallback_mode = PINS.fallback_mode.value\nmain()\nPINS.state.set(state)"
